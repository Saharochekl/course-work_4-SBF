# SBF quickstart (JWST/NIRCam i2d) — документация прототипа

Этот репозиторный скрипт (`sbf_quickstart_ngc1380.py`) реализует прототип измерения SBF (Surface Brightness Fluctuations) на данных JWST/NIRCam i2d (обычно SCI в MJy/sr).
Ключевой результат: оценка флуктуационной звёздной величины $\bar m $ для F150W (и опционально грубый цвет F090W−F150W).

Важно: это не “канонический” пайплайн из статьи. Это рабочая инженерная версия, которая держится на sanity-check’ах, скане радиусов и аккуратной нормировке P_f.

---

## 1. Что такое SBF (в рамках этого кода)

Идея: после удаления гладкого профиля галактики остаются пиксельные флуктуации от конечного числа звёзд + шумы.
Мы оцениваем “амплитуду” этих флуктуаций и приводим её к величине $\bar m$.

В текущем прототипе основная формула:
- Дисперсия флуктуаций в аннулусе:

$$
\sigma^2 \equiv \mathrm{var\_sbf}
$$

- Средняя поверхностная яркость галактики в этом же аннулусе (из гладкой модели):

$$
I_{\mathrm{mean}}
$$

- Нормировка:

$$
P_f = \frac{\sigma^2}{I_{\mathrm{mean}}}
$$

- Перевод в AB величину через нулевую точку для MJy/sr (на пиксель):

$$
\bar m = -2.5\log_{10}(P_f) + ZP_{\mathrm{MJy/sr}}(\Omega_{\mathrm{pix}})
$$

Где mjysr_to_ab_zp(pix_area_arcsec2) даёт ZP с учётом площади пикселя (arcsec²).

---

## 2. Входные данные

Обязательный вход
- --f150w: путь к JWST i2d FITS для F150W (SBF-измерение)

Скрипт ожидает в FITS расширение:
- `SCI` (обязательно)
- `WHT` (если есть, используется для маски валидности WHT>0)

Опциональные входы
- --f090w: второй i2d FITS для F090W (только для грубого цвета)
- --psfref: i2d FITS с “правильным” JWST header, если PSF через stpsf надо считать не из того же файла

---

## 3. Выходные данные

В stdout печатается
- параметры области (N пикселей, std, dyn и т.п.)
- $\sigma^2$, $I_{\mathrm{mean}}$, P_f
- итог:
    - m(F150W) = ... mag
    - (F090W − F150W) ≈ ... mag (если задан --f090w)
    - диагностический скан по радиусам и поиск “плато” \bar m

FITS-файлы рядом с входным
- `*_sbf_model.fits` — гладкая модель галактики
- `*_sbf_resid.fits` — остатки (img − model) с NaN на маске

---

## 4. Общий алгоритм пайплайна

**Шаг 0:** загрузка и валидность пикселей

Функция: `load_i2d(path)`
- Загружаем SCI как float
- valid = isfinite(SCI)
- Если есть WHT: valid &= isfinite(WHT) & (WHT>0)
- Из WCS оцениваем pix_area (arcsec²), нужен для mjysr_to_ab_zp

**Шаг 1:** вычитание фона

Функция: `sigma_clipped_bkg(img, box=128)`

Фон оценивается как медиана по тайлам box×box:
- устойчиво к NaN и ярким объектам
- не является “идеальным” фоном, но для старта работает лучше, чем глобальная медиана

Далее:

img = img_f150 - bkg

**Шаг 2:** маска источников (звезды/ГК/фоновые)

Функция: `mask_sources(img, nsigma, npixels, do_deblend)`
- NaN мостятся (interpolate_replace_nans) для устойчивой сегментации
- порог: thr = bkg + nsigma*rms по sigma_clipped_stats
- detect_sources, затем опциональный deblend_sources
- крупнейшие сегменты удаляются (обычно это сама галактика), остаются компактные

Итоговая маска:

mask = (~valid150) | mask_src

**Шаг 3:** модель галактики (осесимметричная)

Функция: `subtract_galaxy(img, mask, valid)`
1. Центр:

- по умолчанию: guess_center(img, valid) (ярчайший smoothed пиксель)
- можно руками закомментировать и поставить фиксированный (x0,y0)

2. Вырезка:

- берётся квадрат half_size=3000 (настраивается)
- дальше вся модель строится только на вырезке

3. Радиальный профиль:
- build_radial_profile строит медианы по кольцам (dr=1 px) на ok = valid & ~mask
4. “Inpaint” дыр:
- fill_nan_with_radial заполняет bad-пиксели профилем, чтобы кольца не разваливались на seam’ах мозаики
5. Строим 2D модель:
- интерполяция 1D профиля обратно в 2D по радиусу
6. Остатки:

resid = img - model

resid[mask] = NaN

Ограничение: модель не эллиптическая и не изофоты. Это именно радиальная “болванка”.

**Шаг 4:** выбор SBF-аннулуса и sanity-check
- по умолчанию центр для SBF берётся от guess_center(resid, valid)
- аннулус задаётся rin, rout

Маска SBF:

mask_sbf = mask | (~annulus)

Проверка: check_sbf_region(resid, mask_sbf)
- N пикселей достаточно большое (>=5000)
- печатаются min/med/max/mean/std/dyn
- пороги динамического диапазона и std сейчас мягкие (скорее предупреждения)

Если базовый аннулус плохой: скрипт всё равно запускает скан радиусов.

**Шаг 5:** оценка дисперсии SBF

Главное: мы считаем дисперсию по пикселям в аннулусе с обрезкой хвостов:

lo, hi = percentile(vals_sbf, [5,95])
var_sbf = var(vals_sbf[(vals>=lo)&(vals<=hi)])

Это уменьшает влияние немаскированных источников, космиков и “хвостов”.

Шаг 6: Imean по модели

Средняя яркость берётся по модели, в том же аннулусе:

Imean = mean(model[use_I])

Шаг 7: Pf и m̄

Pf   = var_sbf / Imean
mbar = -2.5*log10(Pf) + mjysr_to_ab_zp(area)


---

## 5. Диагностика спектра P(k) и PSF (что реально используется)

В коде есть расчёт P(k) из остатков и E(k) из PSF, и фит:
P(k) = P_0E(k) + P_1

Важно

На текущий момент это диагностика, а не основной путь получения \bar m.
Основная ветка использует var_sbf по пикселям.

Что реально полезно:
- fit_P0 проверяет корреляцию corr(E,P) и отбрасывает мусорные фиты
- в логах печатается отношение var_sbf/P0 как sanity-check (ожидаемо “одного порядка”, но не обязано совпадать)

Что пока “на будущее/сыровато”:
- нормировка E(k) через интеграл (помечено как экспериментальная)
- влияние kmin/kmax на стабильность фита требует отдельного тюнинга

---

## 6. Скан радиусов и “плато” m̄

Функция: `scan_sbf_annuli(...)`

Она пробегает по набору (rin, rout) и печатает для каждого:
- Imean, std, dyn, var_sbf, Pf, m̄

и складывает строки в список rows, после чего вызывает:

`pick_mbar_plateau(rows)`

Идея: найти диапазон колец, где \bar m почти не меняется:
- плато = набор подряд идущих колец, где разброс:

$$
\Delta\bar m \le dm_{\max}
$$

- в коде по умолчанию dm_max ~ 0.4 mag, min_len=3

Это главный инструмент “не самообмана”: если \bar m скачет на ±2–10 mag, значит аннулус грязный или модель/маска уехали.

---

## 7. Практический гайд: как запускать

Базовый запуск

```bash
python sbf_quickstart_ngc1380.py --f150w path/to/F150W_i2d.fits
```

С цветом

```bash
python sbf_quickstart_ngc1380.py --f150w F150W_i2d.fits --f090w F090W_i2d.fits
```

Только проверить фон/маску (без модели и SBF)

```bash
python sbf_quickstart_ngc1380.py --f150w F150W_i2d.fits --dry
```

PSF по другому файлу (если кроп/неполный header)

```bash
python sbf_quickstart_ngc1380.py --f150w crop_i2d.fits --psfref full_i2d.fits
```

---

## 8. Настраиваемые параметры (куда ты реально полезешь)

Маска источников

В main():
- nsigma=2.5 (порог)
- npixels=25 (минимальный размер)
- do_deblend (может быть дорогим и нестабильным)

Размер вырезки под модель

В subtract_galaxy():
- half_size=3000 (для full)
- для кропа обычно нужно меньше

Аннулус SBF

В main():
- rin, rout = 50, 200 (пример)
- выбирается по плато через scan_sbf_annuli

Обрезка хвостов

В дисперсии:
- сейчас [5,95]
- можно сделать [10,90] если хвостов много

---

## 9. Частые проблемы и их смысл

m̄ улетает в 4 mag или в 60 mag

Почти всегда одно из:
- аннулус “грязный” (немаскированные источники/границы мозаики)
- Imean слишком маленький (модель провалилась/не та область)
- var_sbf слишком большой (остатки не белые, модель плохая)
- центр и аннулус сидят не там

Лечение:
- запускать scan_sbf_annuli и выбирать плато
- проверить `*_sbf_model.fits` и `*_sbf_resid.fits` глазами

dyn сотни/тысячи

Обычно значит: в аннулус попали яркие немаскированные источники или край seam’а.

std ~ 1e-4 при MJy/sr

Очень часто это означает, что остатки доминируются структурой (модель плохая) или что область слишком “тихая” и сигнал ушёл под численный шум.

---

## 10. Ограничения текущей версии
- Нет изофот/эллиптичности: галактика считается радиально-симметричной.
- “Восстановление” NaN делается только для построения модели, не для науки.
- Маска источников простая, может:
    - недомаскировать хвосты
    - перемаскировать ядро/структуру
- P(k)/PSF-ветка пока вспомогательная, не основной метод.

---

## 11. Что считать “готовностью” результата

Результат можно считать правдоподобным, если:
1.	По скану радиусов есть плато:
- разброс < 0.5 mag (лучше <0.3)

2.	FITS-остатки визуально выглядят как:

- шум + мелкая “зернистость”
- без крупных градиентов и структур

3.	var_sbf и Imean разумные и устойчивые при малых изменениях rin/rout

